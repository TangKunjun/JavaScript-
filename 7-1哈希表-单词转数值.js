/**
 *
 **/

// 如果我们自己定义一个方案a是1，b是2,....z是26,空格是0（不考虑大小写和特殊字符）

// 假如我们用数值表示单词cats:
   // 相加: 3+1+20+19 = 43
   // 问题: 相加得到数值较小，容易重复

   // 幂的连乘: 3*27 3 + 1*27 2 + 20*27 + 19 = 60337
   // 27表示方案里面的个数，这样基本可以保持唯一性，不会和其他单词重复
   // 问题：如果是zzzzzzzzzz得到的数太大，创建的数组太大，产生很多无效的单词，浪费空间


// 通过一种方法将幂的连乘方案进行压缩


// 哈希化
    // 将大数字转化成数组范围内下标的过程，成为哈希化

// 哈希函数
    // 将单词转成大数字，大数字再进行哈希化的代码实现函数

// 哈希表
    // 最终将数据插入到这个数组，对整个结构进行封装


// 多大数组合适？
    // 如果只有50000个单词，我们定义成两倍也就是100000


// 如何压缩
//     常用的方法为取余操作，假如把0~199的数字用largeNumber代表，压缩为从0~9的数字，用smallNumber代表，下标index = largeNumber % smallNumber
//     当然此时还是会有重复的


// 解决哈希化重复的问题

// 链地址法(拉链法)
    // 每个数组单元中存储的不再是单个数据，而是一个链条（数组或链表）

//开放地址法
    // 寻找数组中空白单元格插入重复的数
    // 线性探测: 在重复的下标后面一直找直到出现了空白单元格
    // 问题: 如果之前的数据是连续的，寻找新的空白单元格耗时

    // 二次探测: 与线性探测一样，只是探测的不长不一样 x+1的二次方、x+2的二次方、x+3的二次方...
    // 问题: 出现二次探测一样步长的聚集还是会影响

    // 再哈希法
    // 把关键字用另一个哈希函数，再次做哈希化，用这次哈希化的结果作为步长
    // 对于指定的关键词，步长在整个探测中是不变的，不过不同的关键词使用不同的步长
    // 第二次哈希化需要具备以下特点:
        // 不能和第一次哈希函数一样(不然结果还是原来的位置)
        // 不能输出为0(否则没有步长成为一个死循环)
    // 其实计算机专家已经设计出了一种很好的哈希函数
        // stepSize = constant - (key % constant)
        // 其中constant是质数，且小于数组的容量
        // 例如: stepSize = 5 - (key % 5),满足需求，并且结果不可能为0

// 链地址法效率往往比开放地址法效率高，所以往往使用的是链地址法

// 优秀的哈希函数要具备：
        // 快速计算，尽量不使用乘法除法
        // 均匀分布

// 霍纳法则：我们通过使用幂的连乘时间复杂度较高，通过霍纳法则可以对公式进行优化
// 使用质数：为了均匀分布，使用常数的地方尽量用质数（开放地址法，步长求余计算的时候非质数会一直循环，质数在求余不会重复）