/*
数据类型：
    线性结构：
        数组：
            补充：其他语言的数组需要进行封装（ArrayList），由于java里面创建数组必须是同一类型的数据，
                 ArrayList可以放不同类型的（这个封装了的数组是Object类型）。
                 js的数组内存可以进行扩容，所以可以存放各种类型还能继续添加。但是Java这类语言在申请数组的时候就固定
                 了内存大小了（数组的容量不会自动改变），Java数组的扩容其实就是申请一个更大的数组把之前小的数组复制到大的数组里面去。
                 数组进行中间插入和删除操作性能比较低，但是数组的查询效率特别高。

        栈结构：
            栈和队列是一种受限制的线性结构，和数组相比只能往栈顶插入，也只能往栈顶删除。类似于弹夹，先入栈的元素后出栈
            特点就是后进先出（LIFO：last in first out）
            程序中，A调用了B，B调用了C，C调用了D，调用顺序是D、C、B、A

        队列结构：
            队列结构和栈的出栈顺序相反，在尾部插入，但只能在头部删除。类似于排队，先入队的先出队
            特点就是先进先出（FIFO：first in first out）
            程序中，线程队列依次来启动线程

            优先级队列：
                再插入数据的时候要考虑该数据的优先级，比如登机，vip用户排队要高于普通用户，计算机中，通过优先级队列来排序列队中的任务顺序


        链表
            链表和数组一样用于存储大量数据，但链表元素中的内存不是连续的，是由每个存储元素本身的节点和指向下一个元素的引用组成。
            优点：可以充分利用计算机的内存，实现灵活的内存动态管理
                 不必在创建的时候就固定内存大小，可以无限的延伸下去
                 在插入和删除数据的时候，时间复制度可以达到O(1),相对数组效率高很多。
            缺点：访问任何元素都要从头开始访问，无法跳过第一个
                 无法通过下标直接访问，需要从头一个一个匹配，访问效率特别低
            类似于火车，有一个火车头，每一节车厢除了有该车厢的乘客之外还会连接下一个车厢



    哈希表：
            通常基于数组实现的，但是基于数组它有很多优势：
                它可以非常快速的插入-删除-查找操作
                哈希表的速度比树还快，基本可以瞬间查找到想要的元素
                哈希表相对于树来说编码更容易

            相对于数组的不足：
                没有顺序，无法以一种固定方式来遍历其中的元素
                通常情况下key值是不允许重复的，不能放置相同的key，用于保存不同的元素

            哈希表结构就是数组，但是它神奇的地方在于对下标值的一种变换，这种变换我们可以称之为哈希函数，通过哈希函数可以获取到hashcode

    树结构：
            通过根延伸出更多的分支，比如dom树；
            通常一个树的节点分支是不确定的，这就导致不好用代码表示。需要换一种方式，每个节点确定分支，一个指向子节点，一个指向兄弟节点。
            这种一个节点有两个分支的就是二叉树，所有的树结构都能用二叉树表示

            二叉树：
                树中每个节点最多只有两个分支
                五种形态：空、只有左子节点、只有右子节点、没有子节点、有左右子节点
                特性：
                    一个二叉树第i层的最大节点数：2^(i-1), i>=1;
                    深度为k的二叉树有最大节点总数为：2^k-1, k>=1;
                    对非空二叉树，若n0表示叶节点的个数，n2是度为2的非叶节点个数，那么两者满足关系n0 = n2+1；
                完美二叉树(满二叉树)，除了最后的叶节点，其他节点都有两个子节点
                完全二叉树：
                    除了最后一层外，其他各层的节点数都达到最大个数，并且最后一层从左至右的叶节点是连续存在的，只缺右侧若干个叶节点
                    完美二叉树是特殊的完全二叉树

                完全二叉树可以使用数组表示，但是非完全二叉树用数组表示会浪费性能，所以用二叉树表示最好用链表的结构进行存储


            二叉搜索树，也称为二叉排序树或二叉查找树
                二叉搜索树是一颗二叉树，可以为空
                如果不为空，需要满足以下条件：
                    非空左子树的所有键值小于其父节点的键值
                    非空右子树的所有键值大于其父节点的键值
                    左右子树本身也是二叉搜索树
                特点：
                    相对较小的值总是在左节点上，相对较大的值总是在右节点上
                    类似于二分法

            二叉搜索树也有一个缺，如果插入的值是逐渐减少或逐渐增大就会一直往左边插入或右边插入，变成链表了
            解决方法：平衡树
                平衡树的种类：
                    AVL平衡树(已经很少用了)
                    红黑树：
                        1、有二叉搜索树的特点
                        2、节点是红色或黑色
                        3、根节点是黑色
                        3、每个叶子节点都是黑色的空节点
                        4、每个红色节点的两个子节点都是黑色的，不能出现连续的红色节点
                        5、从任意节点到叶子节点的路径 包含的黑色节点数量相同

                    红黑树的这些特点可以得到：
                        根节点到叶子节点最长的路径不会超过根节点到叶子节点最短路径的两倍
                        最短的可能路径是全为黑色的路径

                    红黑树为了平衡会做：
                        变色
                        左旋转：使父节点被自己的右节点取代，父节点成为左子节点
                        右旋转：使父节点被自己的左节点取代，父节点成为右子节点

                    通常插入新节点为红色

                平衡树插入：
                    将要插入的节点称为N，父节点为P，祖父节点叫G，父节点的兄弟节点叫U，插入时会遇到一下情况
                    1.新插入的节点N位于根节点，这种情况只要把N变成黑色即可
                    2.新节点的父节点P是黑色节点
                    3.P为红色，U为红色，G为黑色，这种情况要变成P黑，U黑，G红
                      可能出现的问题：G的父节点可能也是红色，这时候就需要递归调整颜色了，如果递归到了根节点就需要进行旋转了
                    4.P为红色，U为黑色，G为黑色，N为左子节点，这时候P变黑，G变红，再进行右旋转
                    5.U为黑色，N为右子节点，这时候以P为根进行左旋转，再将P当做新插入的节点考虑（情况4，P的父节点变黑，P的祖父节点变红，再进行右旋转）
    图结构：
        与树结构有些类似的数据结构，在数学概念上树是图的一种
        主要是顶与边的关系
        与人与人的关系为例：人与人之间可以通过某个人产生关系，顶点就是这个人，6度空间理论指两个人之间的关系不需要通过6个步骤

           特点：
                一组顶点：通常用V(Vertex)表示顶点的集合
                一组边：通常用E(Edge)表示边的集合
                边上顶点和顶点之间的连线
                边可以是有向的也可以是无向的
           术语：
                顶点
                边
                度：一个顶点的度是相邻顶点的数量
                路径：顶点的连续序列
                简单路径：不包含重复的路径
                回路：第一个顶点和最后一个顶点相同的路径
                无向图：所有的边都没有方向
                有向图：图中的边是有方向的
                无权图：边没有带权重
                带权图：边带了权重

        常见的表示方式：
            邻接矩阵
                通过二维数组表示边，0表示没有顶点之间没有边，1表示有边

                问题：
                    如果是稀疏图（连线少）会有大量的0，1则特别少，浪费大量存储空间来表示没有边

            邻接表
                以顶点为key值，存储指向的顶点

                问题：
                    计算出度容易，计算入度麻烦（出度：该顶点指向其他顶点的数量，入度：其他顶点指向该顶点的输入）

        图的遍历：
            和树的遍历一致，每个顶点访问一遍，不能重复访问
            广度优先搜索(BFS)：基于队列，入队列的顶点先被探索
            深度优先搜索(DFS)：基于栈或使用递归，通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问
            两种遍历算法，都需要明确指定第一个被访问的顶点

    集合:
        集合比较常见的实现方式是哈希表
        集合通常是由一组无序的，不能重复的元素构成




大O表示形式

    O(1)           常数的             不会随着数据量的增减发生变化
    O(long(n))     对数的             代表性是二分查找法
    O(n)           线性的             随着数据量增长而增长
    O(nlong(n))    线性和对数乘积
    O(n²)          平方
    O(2n)          指数的

    推导大O表示法的方式：
        1.用常量1取代运行时间中所有的的加法常量
        2.在修改后的运行次数函数中，只保留最高阶项
        3.如果最高存在且不为1，则去除与这个相乘的常数



排列和搜索

*/
